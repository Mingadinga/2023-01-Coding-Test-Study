## 1620 포켓몬 마스터
**딕셔너리 이용**
처음에는 그냥 리스트로 문제 해결을 하려고 했는데 시간 초과가 발생하여 딕셔너리를 이용했다

**[풀이]**
1) 먼저 n만큼 반복문 돌면서 i를key로 하고 입력값을 value로 하는 딕셔너리(data) 생성
2) 위에서 만든 딕셔너리를 뒤집은 딕셔너리(re_data) 생성 (key가 포켓몬 이름이고 vlaue가 i)
3) m만큼 반복문 돌면서 입력값마다 숫자이면 data라는 딕셔너리에서 포켓몬 이름이면 re_data라는 딕셔너리에서 key값으로 value출력

<br/>

## 2075 N번째 큰 수
**힙 이용**
힙을 만들어 그 안에 입력값들을 저장하고 그 힙을 뒤집어서 최대 힙을 다시 만들어서 풀려고 했으나 메모리 초과가 발생하여서 그대로 최소 힙에서 n번째 큰 수를 찾는 방식으로 변경했다

**[풀이]**
n번째 큰 수를 찾아야 하기 때문에 힙의 길이를 n개로 유지하면서 최소힙의 루트값보다 큰 값을 계속 넣어주면 모든 입력값들의 상위 n개만 결국 힙에 남게 되고 그 힙의 루트값이 n번째 큰 수임을 이용하여 문제를 해결한다
1) data라는 힙에 아무것도 없다면 입력값을 그대로 넣는다
2) data라는 힙에 값이 있다면 data힙의 루트값과 입력값을 비교하여 루트값보다 입력값이 크다면 입력값을 힙에 넣고 루트값을 힙에서 삭제한다
3) 모든 입력값에 대해 위의 과정을 실행한 뒤 힙의 루트값 출력

<br/>

## 11279 최대 힙
**힙 이용**
최대 힙을 만들면 끝!

**[풀이]**
1) 입력값을 하나씩 받을 때 0일 때와 아닐 때를 구분
2) 0이 아니라면 최대 힙을 만들어야 하므로 입력값에 -부호 붙인 것과 아닌 것(-x, x) 형태의 튜플로 힙에 값을 넣는다
3) 입력값이 0이고 힙이 비어있지 않다면 힙의 루트값을 출력해야 하므로 튜플의 2번째 원소, 즉 인덱스 1번의 값을 출력
4) 입력값이 0인데 힙이 비어있다면 숫자 0 출력

<br/>

## 14425 문자열 집합
**집합 이용**
집합을 만들면 끝!

**[풀이]**
1) n만큼 반복문을 돌면서 s라는 집합에 입력값들을 넣는다
2) 문자열을 입력 받고 그 문자열이 s 안에 있다면 answer를 1씩 증가시킨다
3) 반복문이 끝나면 answer 출력

<br/>

## 21939 문제 추천 시스템 Version 1
**딕셔너리 이용**
일단 딕셔너리를 이용하여 풀었더니 python말고 pypy3로 해야 통과되었다. 그래서 딕셔너리가 아닌 힙을 사용해야 python3으로 통과할 수 있을 것 같다

**[풀이]**
1) 먼저 문제 리스트 P를 딕셔너리로 만들었다. n만큼 반복문을 돌면서 값을 넣는다
2) 이때 문제 번호를 p, 난이도를 l이라고 하면 l을 key값으로 하고 p를 value로 하였다
3) 나중에 똑같은 난이도의 다른 문제가 들어올 경우를 생각하여 value는 리스트로 만들어서 넣었고 l이 이미 P안에 있다면 value 리스트에 p를 append하였다
4) 명령문의 개수 m을 입력받고 m만큼 다음 과정을 반복한다
5) 한 줄씩 입력 받고 그것을 c라고 하고 리스트로 만든다
6) 딕셔너리 P를 탐색하면서 만약 vlaue인 리스트가 비어있는지 아닌지를 검사하고 비어있지 않은 key-value쌍만 골라서 딕셔너리(new_P)를 새로 생성한다(만약 리스트가 비어 있다면 recommend명령어를 입력받았을 때 빈 리스트에서 값을 출력하게 될 수도 있고 에러가 발생할 수 있으므로 그것을 방지하기 위함이다)
7) 명령어(c[0])가 'solved'라면 P에서 key-value쌍(k-v)을 돌면서 문제 번호(c[1])가 v안에 있다면 리스트 v에서 c[1]을 remove한다
8) 명령어(c[0])가 'add'라면 먼저 난이도(c[2])가 P안에 있는 지를 따져서 P 안에 있다면 value인 리스트에 append하고 P안에 없다면 P에 새로 추가한다
9) 명령어(c[0])가 'recommend'라면 x(c[1])가 1일 때와 아닐 때를 구분한다
10) x(c[1])가 1이라면 new_P에서 key중 최대값을 찾고 그에 해당하는 value 리스트 안에서 최대값을 찾아서 출력한다
11) x(c[1])가 1이 아니라면 new_P에서 key중 최소값을 찾고 그에 해당하는 value리스트 안에서 최소값을 찾아서 출력한다

